stages:
  - test
  - versioning
  - build
  - release
  - push_version

default:
  image: docker:27
  services:
    - name: docker:27-dind
      alias: docker
      command: [ "--host=tcp://0.0.0.0:2375", "--host=unix:///var/run/docker.sock", "--tls=false" ]
  before_script:
    - docker info

variables:
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: "" # This instructs Docker not to start over TLS


Test:
  stage: test
  image:
    name: python:3.11-bookworm # adjust the Python version as necessary

  services:
    - name: postgres:15-alpine
    - name: rabbitmq:3.13-management-alpine
    - name: redis:7-alpine

  variables:
    DB_HOST: postgres
    DB_NAME: test_finmars
    DB_USER: test_finmars_user
    DB_PASSWORD: test_finmars_password
    DB_PORT: 5432
    REPLICA_DB_HOST: postgres
    REPLICA_DB_NAME: test_finmars
    REPLICA_DB_USER: test_finmars_user
    REPLICA_DB_PASSWORD: test_finmars_password
    REPLICA_DB_PORT: 5432
    RABBITMQ_HOST: rabbitmq
    RABBITMQ_USER: test_finmars_user
    RABBITMQ_PASSWORD: test_finmars_password
    RABBITMQ_PORT: 5672
    REDIS_HOST: redis
    REDIS_PORT: 6379

  before_script:
    - pip install --upgrade pip && pip install -r requirements-test.txt
    - mkdir -p /var/log/finmars/backend
  script:
    - coverage run --parallel-mode manage.py test --parallel auto
    - coverage combine && coverage report && coverage html
  artifacts:
    paths:
      - ./coverage_html_report


Versioning:
  stage: versioning
  image:
    name: python:3.11-bookworm
  before_script:
    - pip install haikunator
  script:
    - |
      if [[ $CI_COMMIT_REF_NAME == *"-rc" || $CI_COMMIT_REF_NAME == *"-stable" ]]; then
        FANCY_NAME=$(python -c 'from haikunator import Haikunator; print(Haikunator().haikunate(token_length=0))')
        FULL_VERSION_NAME="$CI_COMMIT_REF_NAME-$CI_PIPELINE_ID-$FANCY_NAME"
        echo "FULL_VERSION_NAME=$FULL_VERSION_NAME"
        echo "IMAGE_TAG=$(echo $FULL_VERSION_NAME)" >> build.env
      fi
  artifacts:
    reports:
      dotenv: build.env
  only:
    - /^.*-(rc|stable)$/


Push Version:
  stage: push_version
  image:
    name: python:3.11-bookworm
    pull_policy: if-not-present # available: always, if-not-present,
  before_script:
    - apt install curl git
  script:
    - |
      if [[ "$CI_COMMIT_REF_NAME" == *"-rc" ]]; then
          CHANNEL="rc"
      elif [[ "$CI_COMMIT_REF_NAME" == *"-stable" ]]; then
          CHANNEL="stable"
      else
          CHANNEL="unknown"
      fi

      # Create the JSON payload
      NOTES=$(git log -1 --pretty=%f)
      JSON_PAYLOAD="{ \"app\": \"$CI_PROJECT_NAME\", \"version\": \"$IMAGE_TAG\", \"build_number\": $CI_PIPELINE_ID, \"notes\": \"$NOTES\", \"channel\": \"$CHANNEL\"  }"

      echo "----- Build Payload -----"
      echo "$JSON_PAYLOAD"
      echo "-------------------------"
      
      status_code=$(curl -o /dev/null -s -w "%{http_code}" --request POST https://license.finmars.com/api/v1/version/ --header "Content-Type: application/json" --data "$JSON_PAYLOAD")
      
      if [[ "$status_code" -ne "201" ]]; then
        echo "Build failed. Status Code: $status_code"
        exit 1
      else
        echo "Build succeeded."
      fi

  only:
    - /^.*-(rc|stable)$/
    - tags


Build:
  stage: build
  before_script:
    # to debug runner
    - df
    - cat /etc/resolv.conf
    - cat /etc/hosts
    #
    - echo -n $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin git.finmars.com:5050
  script:
    - IMAGE_TAG=${IMAGE_TAG:-$CI_COMMIT_REF_NAME}
    - docker build --pull --no-cache --tag $CI_REGISTRY_IMAGE:$IMAGE_TAG .
    - docker push $CI_REGISTRY_IMAGE:$IMAGE_TAG
  only:
    - /^.*-(rc|stable)$/


Release latest:
  stage: release
  variables:
    # We are just playing with Docker here.
    # We do not need GitLab to clone the source code.
    GIT_STRATEGY: none
  only:
    # Only "master" should be tagged "latest"
    - master
  before_script:
    - echo -n $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin git.finmars.com:5050
  script:
    # Because we have no guarantee that this job will be picked up by the same runner
    # that built the image in the previous step, we pull it again locally
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
    # Then we tag it "latest"
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME $CI_REGISTRY_IMAGE:latest
    # And we push it.
    - docker push $CI_REGISTRY_IMAGE:latest


Release version:
  stage: release
  variables:
    # Again, we do not need the source code here. Just playing with Docker.
    GIT_STRATEGY: none
  only:
    # We want this job to be run on tags only.
    - tags
  before_script:
    - echo -n $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin git.finmars.com:5050
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
